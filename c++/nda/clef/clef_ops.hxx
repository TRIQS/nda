/* 
 
  File is generated by vim.
   To regenerate the file,
     1- load the vim function by (or add this to your .vim ?)
        :source ../vimexpand.vim
     2- all it
      call VimExpand2Simple()
 
  ----  normal mapping -------


  VIMEXPAND2 plus,+ minus,- multiplies,* divides,\/ greater,> less,< leq,<= geq,>=  
  // operation @2
  template <typename L, typename R>
  FORCEINLINE decltype(auto) invoke_operation(tags::@1, L &&l, R &&r) {
    return std::forward<L>(l) @2 std::forward<R>(r);
  }

  VIMEXPAND2 plus,+ minus,- multiplies,* divides,\/ greater,> less,< leq,<= geq,>=  
  // @2
  template <typename L, typename R>
  requires(Lazy<L> or Lazy<R>) FORCEINLINE auto operator@2(L &&l, R &&r) { return make_expr<tags::@1>(std::forward<L>(l), std::forward<R>(r)); }

  VIMEXPAND2 unaryplus,+ negate,- loginot,! 
  // operation @2
  template <typename L>
  FORCEINLINE decltype(auto) invoke_operation(tags::@1, L &&l) {
    return  @2 std::forward<L>(l);
  }

  VIMEXPAND2 unaryplus,+ negate,- loginot,! 
  // @2
  template <Lazy L>
   FORCEINLINE auto operator@2(L &&l) { return make_expr<tags::@1>(std::forward<L>(l)); }

  VIMEXPAND2 plus,+ minus,- multiplies,* divides,\/ greater,> less,< leq,<= geq,>=  unaryplus,+ negate,- loginot,! 
  inline const char * get_tag_name(tags::@1) { return  "@2";}

*/

namespace nda::clef {

  // Terminal
  template <typename L>
  FORCEINLINE L invoke_operation(tags::terminal, L &&l) {
    return std::forward<L>(l);
  }

  // Function call
  template <typename F, typename... Args>
  FORCEINLINE decltype(auto) invoke_operation(tags::function, F &&f, Args &&... args) {
    return (std::forward<F>(f))(std::forward<Args>(args)...);
  }

  // []
  template <typename F, typename Args0, typename... Args>
  FORCEINLINE decltype(auto) invoke_operation(tags::subscript, F &&f, Args0 &&args0, Args &&... args) {
    if constexpr (sizeof...(Args) > 0) // no multiple arg, we pass a tuple
      return std::forward<F>(f)[make_comma_tuple(std::forward<Args0>(args0), std::forward<Args>(args)...)];
      //return std::forward<F>(f)[comma_tuple{std::make_tuple(std::forward<Args0>(args0), std::forward<Args>(args)...)}];
    else
      return std::forward<F>(f)[std::forward<Args0>(args0)]; // compiler does not accept ... with ], so we have to make arg0, args...
  }

  // the only ternary node :  expression if
  template <typename C, typename A, typename B>
  FORCEINLINE decltype(auto) invoke_operation(tags::if_else, C const &c, A const &a, B const &b) {
    return c ? a : b;
  }

  // operator is : if_else( Condition, A, B)
  template <typename C, typename A, typename B>
  FORCEINLINE auto if_else(C &&c, A &&a, B &&b) {
    return make_expr<tags::if_else>(std::forward<C>(c), std::forward<A>(a), std::forward<B>(b));
  }

  // --- VIMEXPAND_START  generated : do not edit, cf vim macro above ...

  // operation +
  template <typename L, typename R>
  FORCEINLINE decltype(auto) invoke_operation(tags::plus, L &&l, R &&r) {
    return std::forward<L>(l) + std::forward<R>(r);
  }

  // operation -
  template <typename L, typename R>
  FORCEINLINE decltype(auto) invoke_operation(tags::minus, L &&l, R &&r) {
    return std::forward<L>(l) - std::forward<R>(r);
  }

  // operation *
  template <typename L, typename R>
  FORCEINLINE decltype(auto) invoke_operation(tags::multiplies, L &&l, R &&r) {
    return std::forward<L>(l) * std::forward<R>(r);
  }

  // operation /
  template <typename L, typename R>
  FORCEINLINE decltype(auto) invoke_operation(tags::divides, L &&l, R &&r) {
    return std::forward<L>(l) / std::forward<R>(r);
  }

  // operation >
  template <typename L, typename R>
  FORCEINLINE decltype(auto) invoke_operation(tags::greater, L &&l, R &&r) {
    return std::forward<L>(l) > std::forward<R>(r);
  }

  // operation <
  template <typename L, typename R>
  FORCEINLINE decltype(auto) invoke_operation(tags::less, L &&l, R &&r) {
    return std::forward<L>(l) < std::forward<R>(r);
  }

  // operation <=
  template <typename L, typename R>
  FORCEINLINE decltype(auto) invoke_operation(tags::leq, L &&l, R &&r) {
    return std::forward<L>(l) <= std::forward<R>(r);
  }

  // operation >=
  template <typename L, typename R>
  FORCEINLINE decltype(auto) invoke_operation(tags::geq, L &&l, R &&r) {
    return std::forward<L>(l) >= std::forward<R>(r);
  }

  // +
  template <typename L, typename R>
  requires(Lazy<L> or Lazy<R>) FORCEINLINE auto operator+(L &&l, R &&r) {
    return make_expr<tags::plus>(std::forward<L>(l), std::forward<R>(r));
  }

  // -
  template <typename L, typename R>
  requires(Lazy<L> or Lazy<R>) FORCEINLINE auto operator-(L &&l, R &&r) {
    return make_expr<tags::minus>(std::forward<L>(l), std::forward<R>(r));
  }

  // *
  template <typename L, typename R>
  requires(Lazy<L> or Lazy<R>) FORCEINLINE auto operator*(L &&l, R &&r) {
    return make_expr<tags::multiplies>(std::forward<L>(l), std::forward<R>(r));
  }

  // /
  template <typename L, typename R>
  requires(Lazy<L> or Lazy<R>) FORCEINLINE auto operator/(L &&l, R &&r) {
    return make_expr<tags::divides>(std::forward<L>(l), std::forward<R>(r));
  }

  // >
  template <typename L, typename R>
  requires(Lazy<L> or Lazy<R>) FORCEINLINE auto operator>(L &&l, R &&r) {
    return make_expr<tags::greater>(std::forward<L>(l), std::forward<R>(r));
  }

  // <
  template <typename L, typename R>
  requires(Lazy<L> or Lazy<R>) FORCEINLINE auto operator<(L &&l, R &&r) {
    return make_expr<tags::less>(std::forward<L>(l), std::forward<R>(r));
  }

  // <=
  template <typename L, typename R>
  requires(Lazy<L> or Lazy<R>) FORCEINLINE auto operator<=(L &&l, R &&r) {
    return make_expr<tags::leq>(std::forward<L>(l), std::forward<R>(r));
  }

  // >=
  template <typename L, typename R>
  requires(Lazy<L> or Lazy<R>) FORCEINLINE auto operator>=(L &&l, R &&r) {
    return make_expr<tags::geq>(std::forward<L>(l), std::forward<R>(r));
  }

  // operation +
  template <typename L>
  FORCEINLINE decltype(auto) invoke_operation(tags::unaryplus, L &&l) {
    return +std::forward<L>(l);
  }

  // operation -
  template <typename L>
  FORCEINLINE decltype(auto) invoke_operation(tags::negate, L &&l) {
    return -std::forward<L>(l);
  }

  // operation !
  template <typename L>
  FORCEINLINE decltype(auto) invoke_operation(tags::loginot, L &&l) {
    return !std::forward<L>(l);
  }

  // +
  template <Lazy L>
  FORCEINLINE auto operator+(L &&l) {
    return make_expr<tags::unaryplus>(std::forward<L>(l));
  }

  // -
  template <Lazy L>
  FORCEINLINE auto operator-(L &&l) {
    return make_expr<tags::negate>(std::forward<L>(l));
  }

  // !
  template <Lazy L>
  FORCEINLINE auto operator!(L &&l) {
    return make_expr<tags::loginot>(std::forward<L>(l));
  }

  inline const char *get_tag_name(tags::plus) { return "+"; }

  inline const char *get_tag_name(tags::minus) { return "-"; }

  inline const char *get_tag_name(tags::multiplies) { return "*"; }

  inline const char *get_tag_name(tags::divides) { return "/"; }

  inline const char *get_tag_name(tags::greater) { return ">"; }

  inline const char *get_tag_name(tags::less) { return "<"; }

  inline const char *get_tag_name(tags::leq) { return "<="; }

  inline const char *get_tag_name(tags::geq) { return ">="; }

  inline const char *get_tag_name(tags::unaryplus) { return "+"; }

  inline const char *get_tag_name(tags::negate) { return "-"; }

  inline const char *get_tag_name(tags::loginot) { return "!"; }

} // namespace nda::clef
