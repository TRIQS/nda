// Copyright (c) 2020 Simons Foundation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0.txt
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include "../clef.hpp"
#include <cmath>
#include <complex>

/* 
 
  File is generated by vim.
   To regenerate the file,
     1- load the vim function by (or add this to your .vim ?)
        :source vimexpand.vim
     2- all it
      call VimExpand2Simple()
 
  ----  normal mapping -------

 VIMEXPAND cos sin tan cosh sinh tanh acos asin atan exp log sqrt abs floor pow conj 
 template <Lazy A>                                                                                          
  auto @(A && a) {                                                                                         
    return make_expr_call([]<typename T>(T && x) -> decltype(auto) { using std::@; return @(std::forward<T>(x)); }, std::forward<A>(a));
  }

 */
namespace nda::clef {

  // --- VIMEXPAND_START  generated : do not edit, cf vim macro above ...

  template <Lazy A>
  auto cos(A &&a) {
    return make_expr_call(
       []<typename T>(T &&x) -> decltype(auto) {
         using std::cos;
         return cos(std::forward<T>(x));
       },
       std::forward<A>(a));
  }

  template <Lazy A>
  auto sin(A &&a) {
    return make_expr_call(
       []<typename T>(T &&x) -> decltype(auto) {
         using std::sin;
         return sin(std::forward<T>(x));
       },
       std::forward<A>(a));
  }

  template <Lazy A>
  auto tan(A &&a) {
    return make_expr_call(
       []<typename T>(T &&x) -> decltype(auto) {
         using std::tan;
         return tan(std::forward<T>(x));
       },
       std::forward<A>(a));
  }

  template <Lazy A>
  auto cosh(A &&a) {
    return make_expr_call(
       []<typename T>(T &&x) -> decltype(auto) {
         using std::cosh;
         return cosh(std::forward<T>(x));
       },
       std::forward<A>(a));
  }

  template <Lazy A>
  auto sinh(A &&a) {
    return make_expr_call(
       []<typename T>(T &&x) -> decltype(auto) {
         using std::sinh;
         return sinh(std::forward<T>(x));
       },
       std::forward<A>(a));
  }

  template <Lazy A>
  auto tanh(A &&a) {
    return make_expr_call(
       []<typename T>(T &&x) -> decltype(auto) {
         using std::tanh;
         return tanh(std::forward<T>(x));
       },
       std::forward<A>(a));
  }

  template <Lazy A>
  auto acos(A &&a) {
    return make_expr_call(
       []<typename T>(T &&x) -> decltype(auto) {
         using std::acos;
         return acos(std::forward<T>(x));
       },
       std::forward<A>(a));
  }

  template <Lazy A>
  auto asin(A &&a) {
    return make_expr_call(
       []<typename T>(T &&x) -> decltype(auto) {
         using std::asin;
         return asin(std::forward<T>(x));
       },
       std::forward<A>(a));
  }

  template <Lazy A>
  auto atan(A &&a) {
    return make_expr_call(
       []<typename T>(T &&x) -> decltype(auto) {
         using std::atan;
         return atan(std::forward<T>(x));
       },
       std::forward<A>(a));
  }

  template <Lazy A>
  auto exp(A &&a) {
    return make_expr_call(
       []<typename T>(T &&x) -> decltype(auto) {
         using std::exp;
         return exp(std::forward<T>(x));
       },
       std::forward<A>(a));
  }

  template <Lazy A>
  auto log(A &&a) {
    return make_expr_call(
       []<typename T>(T &&x) -> decltype(auto) {
         using std::log;
         return log(std::forward<T>(x));
       },
       std::forward<A>(a));
  }

  template <Lazy A>
  auto sqrt(A &&a) {
    return make_expr_call(
       []<typename T>(T &&x) -> decltype(auto) {
         using std::sqrt;
         return sqrt(std::forward<T>(x));
       },
       std::forward<A>(a));
  }

  template <Lazy A>
  auto abs(A &&a) {
    return make_expr_call(
       []<typename T>(T &&x) -> decltype(auto) {
         using std::abs;
         return abs(std::forward<T>(x));
       },
       std::forward<A>(a));
  }

  template <Lazy A>
  auto floor(A &&a) {
    return make_expr_call(
       []<typename T>(T &&x) -> decltype(auto) {
         using std::floor;
         return floor(std::forward<T>(x));
       },
       std::forward<A>(a));
  }

  template <Lazy A>
  auto pow(A &&a) {
    return make_expr_call(
       []<typename T>(T &&x) -> decltype(auto) {
         using std::pow;
         return pow(std::forward<T>(x));
       },
       std::forward<A>(a));
  }

  template <Lazy A>
  auto conj(A &&a) {
    return make_expr_call(
       []<typename T>(T &&x) -> decltype(auto) {
         using std::conj;
         return conj(std::forward<T>(x));
       },
       std::forward<A>(a));
  }

} // namespace nda::clef
