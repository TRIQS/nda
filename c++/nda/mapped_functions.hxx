#pragma once

#include "map.hpp"
#include "concepts.hpp"

/*
   File is generated by vim.
   To regenerate the file,
     1- load the vim function by (or add this to your .vim ?)
        :source vimexpand.vim
     2- all it
      call VimExpandSimple()


   It is better than C macro, it gives a cleaner code
   (for error messages, no preproc, doc generation : otherwise no doc string ...)

  ----  normal mapping -------

  VIMEXPAND abs imag floor
  /// Maps @ onto the array
  /// \ingroup ArrayFunction
  template <Array A>
  auto @(A &&a)  {
    return nda::map(
       [](auto const &x) {
         using std::@;
         return @(x);
       })(std::forward<A>(a));
  }

 ---------  same, no using std::-------

  VIMEXPAND real abs2 isnan
  /// Maps @ onto the array
  /// \ingroup ArrayFunction
  template <Array A>
  auto @(A &&a) {
    return nda::map(
       [](auto const &x) {return @(x); })(std::forward<A>(a));
  }

 ---------  mapping with matrix excluded -------

  VIMEXPAND exp cos sin tan cosh sinh tanh acos asin atan log sqrt
  /// Maps @ onto the array
  /// \ingroup ArrayNoMatrixFunction
  template <Array A>
  auto @(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::@;
         return @(x);
       })(std::forward<A>(a));
  }

*/

namespace nda {

  // --- VIMEXPAND_START  --DO NOT EDIT BELOW --


  /// Maps abs onto the array
  /// \ingroup ArrayFunction
  template <Array A>
  auto abs(A &&a)  {
    return nda::map(
       [](auto const &x) {
         using std::abs;
         return abs(x);
       })(std::forward<A>(a));
  }

  /// Maps imag onto the array
  /// \ingroup ArrayFunction
  template <Array A>
  auto imag(A &&a)  {
    return nda::map(
       [](auto const &x) {
         using std::imag;
         return imag(x);
       })(std::forward<A>(a));
  }

  /// Maps floor onto the array
  /// \ingroup ArrayFunction
  template <Array A>
  auto floor(A &&a)  {
    return nda::map(
       [](auto const &x) {
         using std::floor;
         return floor(x);
       })(std::forward<A>(a));
  }

  /// Maps real onto the array
  /// \ingroup ArrayFunction
  template <Array A>
  auto real(A &&a) {
    return nda::map(
       [](auto const &x) {return real(x); })(std::forward<A>(a));
  }

  /// Maps abs2 onto the array
  /// \ingroup ArrayFunction
  template <Array A>
  auto abs2(A &&a) {
    return nda::map(
       [](auto const &x) {return abs2(x); })(std::forward<A>(a));
  }

  /// Maps isnan onto the array
  /// \ingroup ArrayFunction
  template <Array A>
  auto isnan(A &&a) {
    return nda::map(
       [](auto const &x) {return isnan(x); })(std::forward<A>(a));
  }

  /// Maps exp onto the array
  /// \ingroup ArrayNoMatrixFunction
  template <Array A>
  auto exp(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::exp;
         return exp(x);
       })(std::forward<A>(a));
  }

  /// Maps cos onto the array
  /// \ingroup ArrayNoMatrixFunction
  template <Array A>
  auto cos(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::cos;
         return cos(x);
       })(std::forward<A>(a));
  }

  /// Maps sin onto the array
  /// \ingroup ArrayNoMatrixFunction
  template <Array A>
  auto sin(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::sin;
         return sin(x);
       })(std::forward<A>(a));
  }

  /// Maps tan onto the array
  /// \ingroup ArrayNoMatrixFunction
  template <Array A>
  auto tan(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::tan;
         return tan(x);
       })(std::forward<A>(a));
  }

  /// Maps cosh onto the array
  /// \ingroup ArrayNoMatrixFunction
  template <Array A>
  auto cosh(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::cosh;
         return cosh(x);
       })(std::forward<A>(a));
  }

  /// Maps sinh onto the array
  /// \ingroup ArrayNoMatrixFunction
  template <Array A>
  auto sinh(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::sinh;
         return sinh(x);
       })(std::forward<A>(a));
  }

  /// Maps tanh onto the array
  /// \ingroup ArrayNoMatrixFunction
  template <Array A>
  auto tanh(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::tanh;
         return tanh(x);
       })(std::forward<A>(a));
  }

  /// Maps acos onto the array
  /// \ingroup ArrayNoMatrixFunction
  template <Array A>
  auto acos(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::acos;
         return acos(x);
       })(std::forward<A>(a));
  }

  /// Maps asin onto the array
  /// \ingroup ArrayNoMatrixFunction
  template <Array A>
  auto asin(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::asin;
         return asin(x);
       })(std::forward<A>(a));
  }

  /// Maps atan onto the array
  /// \ingroup ArrayNoMatrixFunction
  template <Array A>
  auto atan(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::atan;
         return atan(x);
       })(std::forward<A>(a));
  }

  /// Maps log onto the array
  /// \ingroup ArrayNoMatrixFunction
  template <Array A>
  auto log(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::log;
         return log(x);
       })(std::forward<A>(a));
  }

  /// Maps sqrt onto the array
  /// \ingroup ArrayNoMatrixFunction
  template <Array A>
  auto sqrt(A &&a) requires(get_algebra<A> != 'M') {
    return nda::map(
       [](auto const &x) {
         using std::sqrt;
         return sqrt(x);
       })(std::forward<A>(a));
  }
}
